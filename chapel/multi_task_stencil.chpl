
// number of pixel that will end up being blured 
config const n = 10;

// number of task per local
//config const tasksPerLocale = 1;

/*
 * Function: main this method will blur pixels in an array of reals
 * Return: no return 
 */
proc main() {

	writeln();
	
	// initalized array of reals that will end up being blured
	var pixelArray = [1.0, 1.2, 2.4, 3.5, 4.0, 5.0, 6.0, 7.0, 8.7, 9.7];
	writeln("Initially, the orginal is: ", pixelArray);

	// An array to store the resulting pixels and prints it out
	var resulting: [1..n] real;
	writeln("Initially, the result is:  ", resulting);
	writeln();

	// print out the number of locals/ compute nodes that we are using 
	//writeln("This program is running on ", numLocales, " locales");

	// this method will blur 
	blur(pixelArray, resulting);

	// print the updated result at the end
	writeln();
	writeln("the result is updated to:  ", resulting);
} 	

/*
 * Function: blur this method will get the average of the neighboring pixels to blur 
 * Param: pixelArray an array of reals that is generated by force 
 * Param: resulting an array of reals that will hold re blured pixels
 * Return: no return but the arrays are updated by reference
 */
proc blur(pixelArray, resulting) {
	//coforall loc in Locales {
	//	on loc {
			// printing out the current local
			//writeln("It began running on locale #", here.id);
			//writeln();

			coforall i in 1..n {
				// first element with two neighbors
				if i == 1 then 
					resulting[i] = (pixelArray[i] + pixelArray[i + 1]) / 2;
				// last element with two neighbors
				else if i == n then 
					resulting[i] = (pixelArray[i - 1] + pixelArray[i]) / 2;
				// middle elements with 3 neighbors 
				else 
					resulting[i] = (pixelArray[i - 1] + pixelArray[i] + pixelArray[i + 1]) / 3;
				writeln("task number ", i, " of ", n);
				//writeln("It began running on locale #", here.id);
				//writeln("the result is updated to:  ", resulting);
			}
	//	}
	//}
	
} 